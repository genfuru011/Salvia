# 検証・改善タスクメモ

## 1. スレッドセーフ性とログの競合問題 (重要)
現在の `Salvia::SSR::QuickJS` 実装では、QuickJS VM 自体は `Thread.current` を使用してスレッドローカルに保持されていますが、**ログを格納する `@js_logs` インスタンス変数が全スレッドで共有されています。**

*   **問題点**: 
    *   複数のリクエストが同時に処理される際、あるリクエストのログを別のリクエストが `flush_logs` で取得してしまう可能性があります。
    *   `Array#<<` 操作の競合により、ログが消失する可能性があります。
*   **検証・修正案**:
    *   ログバッファも `Thread.current` に持たせるか、`render` メソッドの戻り値の一部としてログを返す設計への変更を検討する必要があります。

## 2. パフォーマンスとメモリ消費
*   **VM作成コスト**: スレッドごとに `Quickjs::VM.new` とバンドルの `eval` が実行されます。スレッド数が多い環境（Pumaなど）でのメモリ消費量と、スレッド初回利用時のレイテンシを検証する必要があります。
*   **ベンチマーク**: 
    *   同時接続数が多い場合のレスポンスタイム。
    *   長時間稼働時のメモリリークの有無（QuickJS VMのGC挙動）。

## 3. 他のRubyフレームワーク対応
*   **Roda / Hanami**: 現在は Rails と Sinatra での動作確認のみです。
    *   Rack ミドルウェアとしての統合や、各フレームワーク固有のヘルパーとの連携を検証する必要があります。
    *   特に Hanami 2.x 系との統合は、モダンなRuby開発において需要があります。

## 4. フロントエンドフレームワークの多様性
*   **React / Vue / Svelte / Solid**: 現在は Preact がデフォルトです。
    *   `deno.json` のインポートマップやビルドスクリプト (`build.ts`) が、他のフレームワークのSSRライブラリ（`react-dom/server` など）と正しく連携できるか検証が必要です。
    *   ハイドレーションの仕組みがフレームワークごとに異なるため、`islands.js` の汎用性を高める必要があるかもしれません。

## 5. デプロイメントフロー
*   **本番環境**:
    *   サーバーに `deno` ランタイムが必要です。Heroku や Docker 環境でのセットアップガイド（Buildpackなど）が必要です。
    *   `salvia ssr:build` コマンドと Rails の `assets:precompile` との順序関係や連携フローを確立する必要があります。

## 6. エラーハンドリングの強化
*   **ハイドレーション不整合**: SSRされたHTMLとクライアントサイドのJSが一致しない場合の挙動とリカバリ。
*   **タイムアウト**: JS実行が無限ループに陥った場合の強制終了メカニズム（QuickJSの機能で制限可能か検証）。

## 7. コンポーネントディレクトリと独立性 (User Feedback)
*   **`components/` の利用**:
    *   `app/components/Button.jsx` を作成し、`islands/Counter.jsx` から import して利用することは**可能**です（esbuildが依存関係を解決してバンドルします）。
    *   これにより、UIパーツ（ボタン、カードなど）を再利用可能なコンポーネントとして定義できます。
*   **独立した利用 (Freshとの比較)**:
    *   現状、Ruby側から `<%= island "Name" %>` で呼び出せるのは `islands/` ディレクトリ直下のファイルのみです。
    *   `components/` 内のファイルを直接レンダリングしたい場合は、それを `islands/` に置くか、将来的に「Static Component（JSなしSSR）」としてのサポートを追加する必要があります。
    *   Fresh同様、"Island" として定義されたものだけが、独立したエントリーポイント（ハイドレーション対象）として機能します。

## 8. Server Components vs RSC (React Server Components)
*   **Salviaの `app/components/` (Server Components)**:
    *   **純粋なサーバーサイドレンダリング**: サーバーでJSXをHTML文字列に変換して返すだけです。
    *   **No Client JS**: クライアントにはHTMLとして届くため、JavaScriptは一切配信されず、ハイドレーションもされません（Islandsからインポートされない限り）。
    *   **用途**: ボタン、レイアウト、静的なUIパーツ。従来のERB/Slimの代わりとしてJSXを使うイメージです。
    *   **RSCとの違い**: React Server Components (RSC) は、サーバーで実行されつつ、クライアントコンポーネントと連携し、状態を保持したまま部分更新（ストリーミングやシリアライズ）を行う複雑な仕組みです。Salviaのこれは単なる「JSXテンプレートエンジン」としての利用に近いです。

## 9. View層の代替としての可能性 (ERB/Slimレス)
ユーザーからの指摘通り、Salviaのコンポーネント(SSR)を全面的に採用することで、ERBやSlimの記述を最小限に抑えることが理論上可能です。

*   **極端な構成**:
    *   Rails/SinatraのView (ERB) は `layout.erb` と、各アクションで `<%= island 'PageRoot', props %>` を呼び出すだけの薄いラッパーになる。
    *   UIロジック、条件分岐、ループなどは全て JSX (Preact) 側で完結する。
*   **具体的な開発フロー**:
    1.  RubyのControllerでデータを取得 (`@users = User.all`)。
    2.  View (ERB) は `<%= salvia_island "UsersPage", users: @users %>` の1行のみ。
    3.  `app/islands/UsersPage.jsx` (または `components/`) でリスト表示やレイアウトを全て記述。
*   **メリット**:
    *   フロントエンド(JSX)とバックエンド(Ruby)の境界が明確になる。
    *   Reactエコシステムの恩恵（コンポーネントライブラリなど）をフルに受けられる。
*   **RSCとの違い**:
    *   Salviaはあくまで「文字列としてのHTML」をRubyから返しているだけなので、クライアントサイドでのSPA遷移（ページ遷移なしでの書き換え）は自動では行われない（Turbo Driveなどを併用すれば可能）。
    *   データフェッチはRubyのControllerで行い、Propsとして渡す必要がある（RSCのようにコンポーネント内でDBアクセスはできない）。

## 10. 🚀 真のHTML Firstへの道: Turbo Drive + Full SSR JSX
ユーザーの指摘通り、これは「サーバーサイドが主導する真のHTML First」アーキテクチャに非常に近い。

1.  **サーバーでJSXをレンダリング (SSR)**:
    *   ERB/Slimの代わりに、表現力豊かなJSX (TSX) をテンプレートとして使用。
    *   コンポーネント指向でUIを構築できる。
    *   出力は純粋なHTML。

2.  **Turbo DriveでSPA風の遷移**:
    *   ページ遷移はTurbo Driveがインターセプトし、bodyを置換。
    *   ブラウザはHTMLを受け取って表示するだけ。JSの初期化コストが極小。

3.  **必要な部分だけIsland**:
    *   インタラクティブな部分だけ `islands/` に配置してHydration。
    *   それ以外の `components/` はただのHTML文字列になるため、クライアントサイドのJSバンドルサイズを圧迫しない。

**結論**:
Salviaは単なる「RailsでReactを使うツール」ではなく、**「JSXをサーバーサイドテンプレートエンジンとして使い、Turboで配信する」** という新しいRailsフロントエンドの標準形になり得るポテンシャルがある。

- **検証事項**:
  - Turbo Driveのキャッシュ復元時にIslands（Preact）のハイドレーションが正しく再実行されるか？（`turbo:load` イベントでの再マウント処理が必要かも）

## 11. 結論 (2025-12-10)
現状のアーキテクチャ（Islands Architecture）で進める方針で確定。
- **Islands (`app/islands/`)**: クライアントサイドでのハイドレーションが必要なコンポーネント（インタラクティブなボタン、カウンターなど）。
- **Components (`app/components/`)**: Islandsからインポートして使う、またはSSRのみで使う静的なUIパーツ。これらは単体ではハイドレーションされないが、Islandsの一部として組み込まれれば機能する。

Freshのように「Islandsディレクトリにあるものだけがハイドレーションのエントリーポイントになる」という仕様は、バンドルサイズを抑え、明示的な境界を作る上で理にかなっているため、このまま維持する。
